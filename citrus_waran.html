<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CitrusArcade — Waran Hunt (Prototype)</title>
<style>
  :root{
    --bg:#07120a;
    --panel:#0f1a12;
    --leaf:#1e6a28;
    --accent:#ffd166;
    --accent2:#ff8a00;
    --muted:#98b29a;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,var(--bg), #04100a);color:#eaf7ea;-webkit-font-smoothing:antialiased}
  header{display:flex;align-items:center;gap:12px;padding:10px 16px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-bottom:1px solid rgba(255,255,255,0.02)}
  #logoBtn{width:56px;height:56px;border-radius:12px;background:linear-gradient(180deg,var(--leaf),#133f1a);display:flex;align-items:center;justify-content:center;cursor:pointer;border:2px solid rgba(255,255,255,0.04)}
  #logoBtn span{font-weight:900;color:var(--accent2)}
  header h1{font-size:1.05rem;margin:0}
  .controls{margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#071017;font-weight:700;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--accent)}
  main{max-width:1100px;margin:18px auto;padding:0 16px;display:flex;gap:16px;align-items:flex-start}
  .side{width:320px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
  .map-wrap{flex:1;display:flex;flex-direction:column;align-items:center;gap:8px}
  .map{width:760px;max-width:92vw;height:520px;border-radius:12px;background:
      radial-gradient(circle at 15% 20%, rgba(255,255,255,0.02), transparent 6%),
      linear-gradient(180deg,#082114,#062117);
      position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03);box-shadow:0 20px 50px rgba(0,0,0,0.6)}
  .spot{position:absolute;width:56px;height:56px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#ffd166,#ff8a00);color:#071017;font-weight:800;cursor:pointer;border:2px solid rgba(0,0,0,0.16)}
  /* HUD inside overlay game */
  .hud-inline{display:flex;gap:12px;align-items:center;color:var(--muted);margin-bottom:8px}
  .slot-list{display:flex;flex-direction:column;gap:8px;margin-top:12px}
  .slot-item{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);cursor:pointer;border:1px solid rgba(255,255,255,0.02)}
  /* overlay */
  #overlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.72);z-index:60;align-items:center;justify-content:center}
  .window{width:94%;max-width:980px;height:84%;background:linear-gradient(180deg,#081716,#06120f);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .content{flex:1;display:flex;gap:12px;margin-top:12px}
  .class-card{flex:1;padding:12px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border:1px solid rgba(255,255,255,0.02);cursor:pointer}
  .class-card.selected{outline:2px solid rgba(32,120,55,0.14);box-shadow:0 12px 30px rgba(12,40,20,0.45)}
  /* in-game stage */
  #gameStage{flex:1;background:linear-gradient(180deg,#072116,#05160f);border-radius:8px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.02);}
  /* player, prey styles */
  .player{position:absolute;width:64px;height:40px;border-radius:8px;background:linear-gradient(90deg,#6b3b1a,#2a180a);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:800;box-shadow:0 8px 22px rgba(0,0,0,0.6)}
  .prey{position:absolute;border-radius:6px;padding:6px 8px;background:#ffe0a3;color:#062017;font-weight:700;box-shadow:0 6px 16px rgba(0,0,0,0.45)}
  .prey.small{background:#bfe8a3}
  .prey.medium{background:#ffd19a}
  .prey.large{background:#ffb86b}
  /* mobile joystick and bite button */
  .bottom-controls{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-top:10px}
  .joystick{width:120px;height:120px;border-radius:60px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;border:2px solid rgba(255,255,255,0.02);touch-action:none;position:relative}
  .stick{width:48px;height:48px;border-radius:24px;background:rgba(255,255,255,0.04);position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);}
  .bite-btn{padding:12px 18px;border-radius:12px;background:var(--accent2);color:#071017;font-weight:800;border:none}
  /* hud inside game */
  .inGameHUD{position:absolute;left:12px;top:12px;z-index:50;display:flex;gap:12px;align-items:center}
  .life{background:rgba(255,255,255,0.02);padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
  .score{position:absolute;right:12px;top:12px;padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
  /* small */
  .muted{color:var(--muted)}
  @media (max-width:980px){ main{flex-direction:column;align-items:center} .side{width:92%} .map{width:92%;height:420px} .joystick{width:100px;height:100px} }
</style>
</head>
<body>

<header>
  <button id="logoBtn"><span>CA</span></button>
  <h1>CitrusArcade — Jungle Map</h1>
  <div class="controls">
    <div id="walletLabel" class="muted" style="padding:6px 10px;border-radius:8px;background:var(--glass)">Wallet: Not connected</div>
    <button id="btnWallet" class="ghost">Connect</button>
  </div>
</header>

<main>
  <aside class="side">
    <div style="font-weight:900">Game Slots</div>
    <div class="muted" style="margin-top:6px">Choose a location on the map. Game 1 = Waran Hunt (prototype).</div>
    <div class="slot-list" id="slotList" style="margin-top:12px"></div>

    <div style="margin-top:12px">
      <div class="muted">Selected:</div>
      <div id="selectedSlot" style="font-weight:900;margin-top:6px">—</div>
      <div style="margin-top:12px">
        <button id="openSelected" class="btn" style="width:100%;margin-top:8px">Open Slot</button>
      </div>
    </div>
  </aside>

  <section class="map-wrap">
    <div class="muted" style="margin-bottom:6px">Jungle map — select location</div>
    <div class="map" id="map">
      <!-- 12 spots -->
      <div class="spot s1" data-id="1">1</div>
      <div class="spot s2" data-id="2">2</div>
      <div class="spot s3" data-id="3">3</div>
      <div class="spot s4" data-id="4">4</div>
      <div class="spot s5" data-id="5">5</div>
      <div class="spot s6" data-id="6">6</div>
      <div class="spot s7" data-id="7">7</div>
      <div class="spot s8" data-id="8">8</div>
      <div class="spot s9" data-id="9">9</div>
      <div class="spot s10" data-id="10">10</div>
      <div class="spot s11" data-id="11">11</div>
      <div class="spot s12" data-id="12">12</div>
    </div>
  </section>
</main>

<!-- Overlay: Class selection & Game launch -->
<div id="overlay" role="dialog" aria-hidden="true">
  <div class="window">
    <div class="topbar">
      <div style="display:flex;gap:12px;align-items:center"><div style="font-weight:900">Waran Hunt</div><div id="overlaySlot" class="muted">Slot —</div></div>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="muted">Round: 5:00</div>
        <button id="closeOverlay" class="ghost">Back</button>
      </div>
    </div>

    <div class="content">
      <div style="flex:1;display:flex;flex-direction:column;gap:8px">
        <div style="font-weight:800">Choose your Waran class</div>
        <div style="display:flex;gap:10px">
          <div class="class-card" data-class="speed" id="clsSpeed">
            <div style="font-weight:800">Speed-Waran</div>
            <div class="muted">Fast, low damage • Hit & Run</div>
          </div>
          <div class="class-card" data-class="tank" id="clsTank">
            <div style="font-weight:800">Tank-Waran</div>
            <div class="muted">High damage • Slow</div>
          </div>
          <div class="class-card" data-class="stealth" id="clsStealth">
            <div style="font-weight:800">Stealth-Waran</div>
            <div class="muted">Camouflage • Sneak</div>
          </div>
        </div>

        <div style="margin-top:8px;color:var(--muted)"><strong>Tip:</strong> Auf Mobilgeräten nutze den Joystick. Desktop: WASD + Space (Bite).</div>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="startGameBtn" class="btn">Start Game</button>
          <button id="cancelBtn" class="ghost">Cancel</button>
        </div>
      </div>

      <div style="width:300px;display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center">
        <div style="font-weight:800">Controls</div>
        <div class="muted">Desktop: WASD / Arrows + Space = Bite</div>
        <div class="muted">Mobile: Joystick + Bite button (bottom right)</div>
        <div class="joystick" id="joystick">
          <div class="stick" id="stick"></div>
        </div>
        <div style="width:100%;display:flex;justify-content:center;margin-top:6px;">
          <button id="bitePlaceholder" class="bite-btn">Bite</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Game overlay (in-play) -->
<div id="gameOverlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.75);z-index:80;align-items:center;justify-content:center">
  <div style="width:95%;max-width:980px;height:86%;background:linear-gradient(180deg,#071716,#05120f);border-radius:12px;padding:12px;position:relative;display:flex;flex-direction:column;">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="display:flex;gap:12px;align-items:center">
        <button id="gameBack" class="ghost">Back</button>
        <div class="muted">Waran Hunt</div>
      </div>
      <div style="display:flex;gap:12px;align-items:center">
        <div id="timer" class="muted">05:00</div>
        <div id="scoreDisplay" class="muted">Score: 0</div>
        <div id="livesDisplay" class="muted">Lives: 3</div>
      </div>
    </div>

    <div id="gameStage" style="flex:1;margin-top:8px;background:linear-gradient(180deg,#072116,#051715);border-radius:8px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.02)"></div>

    <div class="bottom-controls" style="margin-top:10px">
      <div style="display:flex;align-items:center;gap:10px">
        <div class="joystick" id="playJoystick"><div class="stick" id="playStick"></div></div>
      </div>
      <div style="display:flex;gap:10px;align-items:center">
        <button id="biteBtn" class="bite-btn">Bite</button>
        <button id="restartBtn" class="ghost">Restart</button>
      </div>
    </div>
  </div>
</div>

<script>
/* Waran Hunt Prototype
   - Single HTML file, pure JS
   - Round timer ~5 minutes (modifiable)
   - Classes: speed/tank/stealth adjust movement/damage/stealth behavior
   - Simple prey spawn (small/medium/large), basic AABB collision
   - Joystick for mobile; WASD for desktop
   - No frameworks, no RPC
*/

/* --------- State & Config --------- */
const CONFIG = {
  roundSeconds: 300, // 5 minutes
  spawnInterval: 1200, // ms base spawn
  preyTypes: [
    { type:'small', points:20, size:[28,20], speed:1.2 },
    { type:'medium', points:80, size:[40,28], speed:1.0 },
    { type:'large', points:250, size:[54,34], speed:0.7 }
  ],
  basePlayerSize: [64,40],
  classes: {
    speed: { speed: 4.2, damage: 6, stamina: 120, stealth: 2 },
    tank:  { speed: 2.6, damage: 16, stamina: 180, stealth: 1 },
    stealth:{ speed: 3.2, damage: 10, stamina: 150, stealth: 5 }
  }
};
let playState = null; // will hold runtime data

/* --------- DOM references --------- */
const slotList = document.getElementById('slotList');
const selectedSlot = document.getElementById('selectedSlot');
const openSelected = document.getElementById('openSelected');
const mapSpots = document.querySelectorAll('.spot');
const overlay = document.getElementById('overlay');
const overlaySlot = document.getElementById('overlaySlot');
const closeOverlay = document.getElementById('closeOverlay');
const startGameBtn = document.getElementById('startGameBtn');
const cancelBtn = document.getElementById('cancelBtn');
const classCards = document.querySelectorAll('.class-card');
const bitePlaceholder = document.getElementById('bitePlaceholder');

const gameOverlay = document.getElementById('gameOverlay');
const gameStage = document.getElementById('gameStage');
const timerEl = document.getElementById('timer');
const scoreDisplay = document.getElementById('scoreDisplay');
const livesDisplay = document.getElementById('livesDisplay');
const gameBack = document.getElementById('gameBack');
const restartBtn = document.getElementById('restartBtn');
const biteBtn = document.getElementById('biteBtn');

/* joystick elements */
const joystick = document.getElementById('joystick');
const stick = document.getElementById('stick');
const playJoystick = document.getElementById('playJoystick');
const playStick = document.getElementById('playStick');

/* slot state */
const slots = Array.from({length:12}, (_,i)=>({id:i+1, name:`Slot ${i+1}`}));
let currentSelectedSlot = null;
let selectedClass = null;

/* ---------- populate side list ---------- */
function renderSlots(){
  slotList.innerHTML = '';
  slots.forEach(s=>{
    const el = document.createElement('div');
    el.className = 'slot-item';
    el.dataset.id = s.id;
    el.innerHTML = `<div style="width:36px;height:36px;border-radius:8px;background:linear-gradient(180deg,var(--leaf),#133f1a);display:flex;align-items:center;justify-content:center;color:var(--accent);font-weight:800">${s.id}</div>
                    <div style="flex:1;margin-left:8px"><div style="font-weight:800">Slot ${s.id}</div><div class="muted">Jungle region ${s.id}</div></div>
                    <div class="muted">Play</div>`;
    el.addEventListener('click', ()=> selectSlot(s.id));
    slotList.appendChild(el);
  });
}
renderSlots();

/* map click handlers */
mapSpots.forEach(sp=>{
  sp.addEventListener('click', ()=> selectSlot(Number(sp.dataset.id)));
});

function selectSlot(id){
  currentSelectedSlot = id;
  selectedSlot.textContent = `Slot ${id}`;
  document.querySelectorAll('.slot-item').forEach(it=>it.classList.toggle('selected', Number(it.dataset.id)===id));
  mapSpots.forEach(s=> s.style.boxShadow = '');
  const spot = document.querySelector(`.spot[data-id="${id}"]`);
  if (spot) spot.style.boxShadow = '0 18px 40px rgba(255,138,0,0.14)';
}

/* open overlay */
openSelected.addEventListener('click', ()=> {
  if (!currentSelectedSlot) return alert('Select a slot first');
  overlay.style.display = 'flex';
  overlaySlot.textContent = `Slot ${currentSelectedSlot}`;
});

/* overlay controls */
closeOverlay.addEventListener('click', ()=> closeClassOverlay());
cancelBtn.addEventListener('click', ()=> closeClassOverlay());
function closeClassOverlay(){ overlay.style.display = 'none'; overlay.setAttribute('aria-hidden','true'); }

/* class selection */
classCards.forEach(c=>{
  c.addEventListener('click', ()=> {
    classCards.forEach(x=>x.classList.remove('selected'));
    c.classList.add('selected');
    selectedClass = c.dataset.class;
  });
});

/* bite placeholder (in overlay) */
bitePlaceholder.addEventListener('click', ()=> alert('In-game Bite control available after starting'));

startGameBtn.addEventListener('click', ()=>{
  if (!selectedClass) return alert('Choose a Waran class first');
  // close overlay and start game
  closeClassOverlay();
  startGame(selectedClass, currentSelectedSlot);
});

/* -------- Game runtime setup -------- */
function startGame(classKey, slotId){
  // init playState
  playState = {
    classKey,
    slotId,
    timeLeft: CONFIG.roundSeconds,
    score: 0,
    lives: 3,
    dtLast: performance.now(),
    preyList: [],
    lastSpawn: performance.now(),
    running: true,
    player: {
      x: 100,
      y: 220,
      vx: 0,
      vy: 0,
      width: CONFIG.basePlayerSize[0],
      height: CONFIG.basePlayerSize[1],
      scale: 1,
      facing: 1, // 1 right, -1 left
      cooldownBite: 0,
      classStats: CONFIG.classes[classKey]
    }
  };

  // show overlay
  gameOverlay.style.display = 'flex';
  gameStage.innerHTML = ''; // clear
  timerEl.textContent = formatTime(playState.timeLeft);
  scoreDisplay.textContent = 'Score: 0';
  livesDisplay.textContent = 'Lives: 3';

  // create player element
  const p = document.createElement('div');
  p.className = 'player';
  p.style.width = `${playState.player.width}px`;
  p.style.height = `${playState.player.height}px`;
  p.style.left = playState.player.x + 'px';
  p.style.top = playState.player.y + 'px';
  p.textContent = 'W';
  gameStage.appendChild(p);
  playState.player.el = p;

  // input initial state
  initInput();

  // start loops
  playState.raf = requestAnimationFrame(gameLoop);
}

/* ------- Input handling (WASD + Joystick) ------- */
const input = { left:0, right:0, up:0, down:0, bite:false };

function initInput(){
  // reset input
  input.left = input.right = input.up = input.down = 0; input.bite = false;
  // keyboard
  function keyDown(e){
    if (!playState || !playState.running) return;
    if (e.key === 'a' || e.key === 'ArrowLeft'){ input.left = 1; }
    if (e.key === 'd' || e.key === 'ArrowRight'){ input.right = 1; }
    if (e.key === 'w' || e.key === 'ArrowUp'){ input.up = 1; }
    if (e.key === 's' || e.key === 'ArrowDown'){ input.down = 1; }
    if (e.code === 'Space'){ input.bite = true; }
  }
  function keyUp(e){
    if (e.key === 'a' || e.key === 'ArrowLeft'){ input.left = 0; }
    if (e.key === 'd' || e.key === 'ArrowRight'){ input.right = 0; }
    if (e.key === 'w' || e.key === 'ArrowUp'){ input.up = 0; }
    if (e.key === 's' || e.key === 'ArrowDown'){ input.down = 0; }
    if (e.code === 'Space'){ input.bite = false; }
  }
  window.addEventListener('keydown', keyDown);
  window.addEventListener('keyup', keyUp);

  // joystick overlay (in overlay class window) — we only use it as visual
  // actual in-game joystick is playJoystick below

  // play joystick for mobile (bottom)
  let active = false;
  let origin = null;
  function startJoy(e){
    active = true;
    origin = getPointerPos(e, playJoystick);
    moveStick(e);
    e.preventDefault();
  }
  function moveStick(e){
    if (!active) return;
    const pos = getPointerPos(e, playJoystick);
    const dx = pos.x - origin.x;
    const dy = pos.y - origin.y;
    const max = 40; // radius
    const mag = Math.sqrt(dx*dx + dy*dy);
    const nx = Math.max(-1, Math.min(1, dx / max));
    const ny = Math.max(-1, Math.min(1, dy / max));
    playStick.style.transform = `translate(${nx*max}px, ${ny*max}px)`;
    // map to input
    input.left = nx < -0.2 ? Math.abs(nx) : 0;
    input.right = nx > 0.2 ? nx : 0;
    input.up = ny < -0.2 ? Math.abs(ny) : 0;
    input.down = ny > 0.2 ? ny : 0;
  }
  function endJoy(){
    active = false;
    playStick.style.transform = `translate(0px,0px)`;
    input.left = input.right = input.up = input.down = 0;
  }
  playJoystick.addEventListener('touchstart', startJoy, {passive:false});
  playJoystick.addEventListener('touchmove', moveStick, {passive:false});
  playJoystick.addEventListener('touchend', endJoy);
  playJoystick.addEventListener('mousedown', startJoy);
  window.addEventListener('mousemove', moveStick);
  window.addEventListener('mouseup', endJoy);

  // bite button
  biteBtn.onclick = ()=> { if (playState) input.bite = true; setTimeout(()=> input.bite=false, 120); };
  // restart
  restartBtn.onclick = ()=> restartGame();
  // back
  gameBack.onclick = ()=> { endGame(); };
}

/* helper to get pointer pos relative to element */
function getPointerPos(ev, el){
  const rect = el.getBoundingClientRect();
  let clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
  let clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
  return { x: clientX - rect.left, y: clientY - rect.top };
}

/* ------- GAME LOOP ------- */
function gameLoop(now){
  if (!playState) return;
  const dt = Math.min(40, now - playState.dtLast);
  playState.dtLast = now;

  // update timer
  playState.timeLeft -= dt/1000;
  if (playState.timeLeft <= 0){
    endRound();
    return;
  }
  timerEl.textContent = formatTime(Math.ceil(playState.timeLeft));

  // spawn prey
  if (now - playState.lastSpawn > CONFIG.spawnInterval * (0.8 + Math.random()*0.8)){
    spawnPrey();
    playState.lastSpawn = now;
  }

  // update prey
  updatePrey(dt);

  // update player
  updatePlayer(dt);

  // collisions
  checkCollisions();

  // update HUD
  scoreDisplay.textContent = `Score: ${Math.floor(playState.score)}`;
  livesDisplay.textContent = `Lives: ${playState.lives}`;

  if (playState.running) playState.raf = requestAnimationFrame(gameLoop);
}

/* ------- Player physics & actions ------- */
function updatePlayer(dt){
  const p = playState.player;
  const stats = p.classStats;
  // movement via input
  let moveX = (input.right - input.left);
  let moveY = (input.down - input.up); // for side-scroller, Y will be limited to small hops or climb; we keep 2D plane
  // normalize
  if (Math.abs(moveX) < 0.05) moveX = 0;
  if (Math.abs(moveY) < 0.05) moveY = 0;

  // speed scaling per class
  const spd = stats.speed;
  p.vx = moveX * spd;
  p.vy = moveY * spd;

  // apply position
  p.x += p.vx * (dt/16.66);
  p.y += p.vy * (dt/16.66);

  // clamp within stage
  const rect = gameStage.getBoundingClientRect();
  p.x = Math.max(6, Math.min(rect.width - p.width - 6, p.x));
  p.y = Math.max(6, Math.min(rect.height - p.height - 6, p.y));

  // scale grows with score (simple)
  const scale = 1 + Math.min(1.2, Math.floor(playState.score/800)/10);
  p.scale = scale;

  // apply to DOM
  p.el.style.left = p.x + 'px';
  p.el.style.top = p.y + 'px';
  p.el.style.transform = `scale(${p.scale})`;

  // facing
  if (p.vx > 0.5) p.facing = 1;
  else if (p.vx < -0.5) p.facing = -1;
  p.el.style.transform += ` translateZ(0)`;

  // bite action (cooldown)
  if (input.bite && p.cooldownBite <= 0){
    doBite();
    p.cooldownBite = 600; // ms cooldown
  }
  if (p.cooldownBite > 0) p.cooldownBite -= dt;
}

/* bite mechanic: check for prey in front within small range */
function doBite(){
  const p = playState.player;
  const facing = p.facing;
  const px = p.x + (facing === 1 ? p.width : -20);
  const py = p.y + p.height/2;
  // find prey within rectangle
  for (let i=0;i<playState.preyList.length;i++){
    const prey = playState.preyList[i];
    if (!prey.el) continue;
    const r = prey.el.getBoundingClientRect();
    const sRect = gameStage.getBoundingClientRect();
    const preyX = prey.x; const preyY = prey.y;
    // compute overlap in stage coords
    const relX = preyX - p.x;
    const relY = preyY - p.y;
    // simple distance
    const dx = (prey.x + prey.width/2) - (p.x + p.width/2);
    const dy = (prey.y + prey.height/2) - (p.y + p.height/2);
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 80 * Math.max(0.8, p.scale)){
      // bite success depends on class damage vs prey size
      const dmg = p.classStats.damage * p.scale;
      // prey health system (1 hit = success but larger prey may need more)
      prey.hp -= dmg;
      if (prey.hp <= 0){
        // consume prey
        playState.score += prey.points;
        // growth visual: increase player scale a bit
        p.scale += Math.min(0.08, prey.points/2000);
        // remove prey element
        if (prey.el) prey.el.remove();
        playState.preyList.splice(i,1);
      } else {
        // if not killed, prey flees (increase speed)
        prey.vx *= 1.6;
      }
      break; // only one prey per bite
    }
  }
}

/* ------- Prey spawn & update ------- */
function spawnPrey(){
  if (!playState) return;
  const rect = gameStage.getBoundingClientRect();
  const spawnEdge = Math.random() > 0.5 ? -80 : rect.width + 40;
  const type = weightedChoice(CONFIG.preyTypes);
  const el = document.createElement('div');
  el.className = 'prey ' + type.type;
  el.style.width = type.size[0] + 'px';
  el.style.height = type.size[1] + 'px';
  el.textContent = type.type === 'small' ? 'in' : (type.type === 'medium' ? 'l' : 'B');
  el.style.left = spawnEdge + 'px';
  el.style.top = Math.random() * (rect.height - 60) + 'px';
  gameStage.appendChild(el);
  const prey = {
    el, type: type.type, points: type.points, x: spawnEdge, y: parseFloat(el.style.top), vx: (spawnEdge < 0 ? type.speed : -type.speed), vy: 0, width: type.size[0], height: type.size[1], hp: type.type === 'large' ? 30 : (type.type === 'medium' ? 12 : 6)
  };
  playState.preyList.push(prey);
}

/* update prey positions */
function updatePrey(dt){
  const rect = gameStage.getBoundingClientRect();
  for (let i = playState.preyList.length-1; i>=0; i--){
    const prey = playState.preyList[i];
    prey.x += prey.vx * (dt/16.66);
    // vertical slight bob
    prey.y += Math.sin((performance.now()+i*100)/600) * 0.4;
    prey.el.style.left = prey.x + 'px';
    prey.el.style.top = prey.y + 'px';
    // out of bounds cleanup
    if (prey.x < -200 || prey.x > rect.width + 200) {
      if (prey.el) prey.el.remove();
      playState.preyList.splice(i,1);
    }
  }
}

/* ------- collisions: prey hitting player (dangerous) ------- */
function checkCollisions(){
  const p = playState.player;
  const px = p.x, py = p.y, pw = p.width*p.scale, ph = p.height*p.scale;
  for (let i = playState.preyList.length-1; i>=0; i--){
    const prey = playState.preyList[i];
    const rx = prey.x, ry = prey.y, rw = prey.width, rh = prey.height;
    if (rectIntersect(px,py,pw,ph, rx,ry,rw,rh)){
      // collision; small prey -> auto-consume (player won't be hurt)
      if (prey.type === 'small'){
        playState.score += prey.points;
        if (prey.el) prey.el.remove();
        playState.preyList.splice(i,1);
      } else {
        // medium/large could hurt player: chance
        const chance = prey.type === 'medium' ? 0.35 : 0.6;
        if (Math.random() < chance){
          // player takes damage / lose life
          playState.lives -= 1;
          // temporary stun: freeze player a bit
          playState.player.vx = 0;
          playState.player.vy = 0;
          // visual feedback
          playState.player.el.style.opacity = 0.5;
          setTimeout(()=> { if (playState && playState.player && playState.player.el) playState.player.el.style.opacity = 1; }, 600);
          if (playState.lives <= 0){
            gameOver();
            return;
          }
        } else {
          // otherwise we auto-consume it (successful ambush)
          playState.score += prey.points;
          if (prey.el) prey.el.remove();
          playState.preyList.splice(i,1);
        }
      }
    }
  }
}

/* ------- Round end and game over ------- */
function endRound(){
  // stop loop and show summary
  if (!playState) return;
  playState.running = false;
  if (playState.raf) cancelAnimationFrame(playState.raf);
  alert(`Round ended! Score: ${Math.floor(playState.score)}\nReturning to map.`);
  endGame();
}

function gameOver(){
  if (!playState) return;
  playState.running = false;
  if (playState.raf) cancelAnimationFrame(playState.raf);
  alert(`Game Over! Score: ${Math.floor(playState.score)}\nReturning to map.`);
  endGame();
}

function endGame(){
  // cleanup DOM and state
  if (!playState) return;
  // remove prey
  playState.preyList.forEach(p=> p.el && p.el.remove());
  playState.player.el && playState.player.el.remove();
  playState.preyList = [];
  playState = null;
  gameOverlay.style.display = 'none';
}

/* restart in current class/slot */
function restartGame(){
  if (!playState) return;
  // cleanup first
  playState.preyList.forEach(p=> p.el && p.el.remove());
  playState.preyList = [];
  playState.score = 0;
  playState.lives = 3;
  playState.timeLeft = CONFIG.roundSeconds;
  // reposition player
  playState.player.x = 100;
  playState.player.y = 220;
  playState.player.el.style.left = '100px';
  playState.player.el.style.top = '220px';
  // resume loop
  playState.running = true;
  playState.dtLast = performance.now();
  playState.raf = requestAnimationFrame(gameLoop);
}

/* ------- Utilities ------- */
function weightedChoice(list){
  // simple uniform random pick (could be weighted)
  const idx = Math.floor(Math.random() * list.length);
  return list[idx];
}
function rectIntersect(x1,y1,w1,h1,x2,y2,w2,h2){
  return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
}
function formatTime(s){
  const m = Math.floor(s/60);
  const sec = Math.floor(s%60).toString().padStart(2,'0');
  return `${m}:${sec}`;
}

/* ------- UI hook-ups for map and overlay closure ------- */
document.getElementById('closeOverlay').addEventListener('click', ()=> closeClassOverlay());
document.getElementById('btnWallet').addEventListener('click', ()=>{
  const lab = document.getElementById('walletLabel');
  if (lab.textContent === 'Wallet: Not connected' || lab.textContent === 'Not connected') {
    lab.textContent = 'DemoWallet…';
    document.getElementById('btnWallet').textContent = 'Disconnect';
  } else {
    lab.textContent = 'Not connected';
    document.getElementById('btnWallet').textContent = 'Connect';
  }
});
document.getElementById('logoBtn').addEventListener('click', ()=> location.reload());

/* overlay triggers when clicking spot */
mapSpots.forEach(sp=> sp.addEventListener('click', ()=> {
  selectSlot(Number(sp.dataset.id));
  overlay.style.display = 'flex';
  overlaySlot.textContent = `Slot ${sp.dataset.id}`;
}));

/* initial selection default */
selectSlot(1);

/* formatting helper to keep timer shown */
setInterval(()=> {
  if (playState && playState.timeLeft) timerEl.textContent = formatTime(Math.ceil(playState.timeLeft));
}, 1000);
</script>

</body>
</html>
